#include <LiquidCrystal_I2C.h>
#include <Keypad.h>
#include <EEPROM.h>
#include <TinyGPSPlus.h>
#include <SoftwareSerial.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);

// Keypad setup
const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {7, 8, 9, 10};
byte colPins[COLS] = {11, 12, 13, A6};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

String phone1 = "", phone2 = "";
bool enteredPhone1 = false, enteredPhone2 = false;
const int slot1 = 0;
const int slot2 = 20;

TinyGPSPlus gps;

// States for non-blocking operations
enum State {
  ST_IDLE,
  ST_SENDING_SMS,
  ST_CALLING,
  ST_HANGUP_DELAY
};

State currentState = ST_IDLE;
unsigned long stateStartTime = 0;

// SMS variables
int smsStage = 0;
String smsMessage = "";
String currentSmsNumber = "";
int smsSendIndex = 0;     // 0 = phone1, 1 = phone2
const unsigned long SMS_DELAY_BETWEEN = 5000; // 5 seconds between SMS

// Call variables
String callNumber = "";
const unsigned long CALL_DURATION =10000; //10 seconds call

void setup() {
  lcd.begin(16, 2);
  lcd.backlight();
  Serial.begin(9600);
  Serial1.begin(9600);  // GSM connected to Mega TX1/RX1
  Serial2.begin(9600);  // GPS connected to Mega Serial2

  loadFromEEPROM();
          
  lcd.clear();
  if (!enteredPhone1) {
    lcd.print("Enter Number 1:");
  } else if (!enteredPhone2) {
    lcd.print("Enter Number 2:");
  } else {
    showMainMenu();
  }
}

void loop() {
  // GPS data decode
  while (Serial2.available()) gps.encode(Serial2.read());

  char key = keypad.getKey();

  if (currentState == ST_IDLE) {
    if (key) {
      if (key == 'A') {
        // Reset
        clearEEPROM();
        phone1 = ""; phone2 = "";
        enteredPhone1 = enteredPhone2 = false;
        lcd.clear(); lcd.print("RESET Done");
        delay(1000);
        lcd.clear(); lcd.print("Enter Number 1:");
        return;
      }

      // Phone entry
      if (!enteredPhone1) {
        handlePhoneEntry(key, phone1, enteredPhone1, "Number 1:", slot1);
        if (enteredPhone1) {
          lcd.clear(); lcd.print("Enter Number 2:");
        }
        return;
      }
      if (!enteredPhone2) {
        handlePhoneEntry(key, phone2, enteredPhone2, "Number 2:", slot2);
        if (enteredPhone2) {
          lcd.clear(); lcd.print("Saved Both!");
          delay(1000);
          showMainMenu();
        }
        return;
      }

      // Main menu actions
      if (key == 'B') {
        // Start SMS sequence
        smsSendIndex = 0;
        currentSmsNumber = phone1;
        prepareSMSMessage();
        smsStage = 0;
        currentState = ST_SENDING_SMS;
        stateStartTime = millis();
        lcd.clear(); lcd.print("SMS to No.1");
      }
      else if (key == 'C') {
        // Call number 1
        currentState = ST_CALLING;
        callNumber = phone1;
        makeCall(callNumber);
        lcd.clear(); lcd.print("Calling No.1");
        stateStartTime = millis();
      }
      else if (key == 'D') {
        // Call number 2
        currentState = ST_CALLING;
        callNumber = phone2;
        makeCall(callNumber);
        lcd.clear(); lcd.print("Calling No.2");
        stateStartTime = millis();
      }
    }
  }

  handleStates();
}

// Handles SMS sending and call hangup states
void handleStates() {
  unsigned long now = millis();

  switch (currentState) {
    case ST_SENDING_SMS:
      switch (smsStage) {
        case 0:
          Serial1.println("AT+CMGF=1");  // text mode
          smsStage = 1; stateStartTime = now;
          break;
        case 1:
          if (now - stateStartTime >= 100) {
            Serial1.print("AT+CMGS=\"+91"); Serial1.print(currentSmsNumber); Serial1.println("\"");
            smsStage = 2; stateStartTime = now;
          }
          break;
        case 2:
          if (now - stateStartTime >= 500) {
            Serial1.print(smsMessage);
            Serial1.write(26); // Ctrl+Z
            smsStage = 3; stateStartTime = now;
          }
          break;
        case 3:
          if (now - stateStartTime >= 3000) {
            if (smsSendIndex == 0 && enteredPhone2) {
              smsSendIndex = 1; smsStage = 4; stateStartTime = now;
              lcd.clear(); lcd.print("Wait 5 sec");
            } else {
              currentState = ST_IDLE;
              lcd.clear(); showMainMenu();
            }
          }
          break;
        case 4:
          if (now - stateStartTime >= SMS_DELAY_BETWEEN) {
            currentSmsNumber = phone2;
            prepareSMSMessage();
            smsStage = 0; stateStartTime = now;
            lcd.clear(); lcd.print("SMS to No.2");
          }
          break;
      }
      break;

    case ST_CALLING:
      if (now - stateStartTime >= CALL_DURATION) {
        hangUp();
        lcd.clear(); lcd.print("Call Ended");
        currentState = ST_HANGUP_DELAY;
        stateStartTime = now;
      }
      break;

    case ST_HANGUP_DELAY:
      if (now - stateStartTime >= 1000) {
        currentState = ST_IDLE;
        showMainMenu();
      }
      break;

    case ST_IDLE:
    default:
      break;
  }
}

// Helper: phone entry
void handlePhoneEntry(char key, String &phone, bool &done, const char* lbl, int addr) {
  if (key == '#') {
    if (phone.length() == 10) {
      saveToEEPROM(phone, addr);
      done = true;
    } else {
      lcd.clear(); lcd.print("Enter 10 digits!"); delay(1500);
    }
    lcd.clear(); lcd.print(lbl);
    return;
  }
  if (key == '*') phone = "";
  else if (phone.length() < 10 && isDigit(key)) phone += key;

  lcd.clear(); lcd.print(lbl);
  lcd.setCursor(0,1); lcd.print("+91"+phone);
}

// EEPROM functions
void saveToEEPROM(String num, int addr) {
  for (int i=0; i<num.length(); i++) EEPROM.write(addr+i, num[i]);
  EEPROM.write(addr+num.length(), '\0');
}
void loadFromEEPROM() {
  phone1 = ""; phone2 = "";
  char c;
  for (int i=0; i<15; i++) {
    c = EEPROM.read(slot1+i);
    if (c=='\0') break;
    phone1 += c;
  }
  enteredPhone1 = (phone1.length()==10);
  for (int i=0; i<15; i++) {
    c = EEPROM.read(slot2+i);
    if (c=='\0') break;
    phone2 += c;
  }
  enteredPhone2 = (phone2.length()==10);
}
void clearEEPROM() {
  for (int i=0; i<40; i++) EEPROM.write(i, 0);
}

// LCD menu
void showMainMenu() {
  lcd.clear();
  lcd.print("B=SMS C=CALL1");
  lcd.setCursor(0,1);
  lcd.print("D=CALL2 A=RST");
}

// Prepare SMS text
void prepareSMSMessage() {
  smsMessage = "Help!\nEmergency Alert!\nLocation:\n";
  if (gps.location.isValid()) {
    smsMessage += "Lat:" + String(gps.location.lat(),6) +
                  " Lon:" + String(gps.location.lng(),6) +
                  "\nhttps://maps.google.com/?q=" +
                  String(gps.location.lat(),6) + "," +
                  String(gps.location.lng(),6);
  } else {
    smsMessage += "Location Not Found";
  }
}

// GSM call functions
void makeCall(const String &num) {
  while (Serial1.available()) Serial1.read();
  Serial1.print("ATD+91"); Serial1.print(num); Serial1.println(";");
}
void hangUp() {
  Serial1.println("ATH");
}
